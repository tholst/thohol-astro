---
import TechBadge from './TechBadge.astro';
import StackTechFold from './StackTechFold.astro';

type Category =
  | 'Languages'
  | 'Frameworks'
  | 'UI'
  | 'Data'
  | 'Identity'
  | 'Integrations'
  | 'Platforms/Hosting'
  | 'Infrastructure'
  | 'Tooling'
  | 'AI Tools'
  | 'AI Models/APIs';

type Tech = { key: string; label: string; href?: string; tags: Category[] };

interface Props {
  contextId: string;
  title: string;
  rangeLabel: string;
  summary?: string;
  tech: Tech[];
  events: Array<{
    dateIso: string;
    dateLabel: string;
    title: string;
    note?: string;
    tech: Tech[];
  }>;
}

const { contextId, title, rangeLabel, summary, tech, events } = Astro.props;

const panelId = `stack-row-panel-${contextId.replace(/[^a-zA-Z0-9_-]/g, '-')}`;

type InlinePart =
  | { type: 'text'; value: string }
  | { type: 'tech'; tech: Tech };

const normalizeToken = (value: string) =>
  value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '');

const findTechFromToken = (
  token: string,
  eventTech: Tech[]
): Tech | undefined => {
  const normalized = normalizeToken(token);
  if (!normalized) return undefined;
  const candidates = [...eventTech, ...tech];
  return candidates.find((item) => {
    const keyId = item.key.includes(':') ? item.key.split(':')[1] : item.key;
    return (
      normalizeToken(keyId) === normalized ||
      normalizeToken(item.label) === normalized
    );
  });
};

const parseInlineTech = (
  input: string | undefined,
  eventTech: Tech[]
): { parts: InlinePart[]; usedKeys: Set<string> } => {
  if (!input) return { parts: [], usedKeys: new Set() };
  const parts: InlinePart[] = [];
  const usedKeys = new Set<string>();
  const re = /\{\{tech:([^}|]+)(?:\|([^}]+))?\}\}/g;
  let last = 0;
  let match: RegExpExecArray | null = null;
  while ((match = re.exec(input)) !== null) {
    if (match.index > last) {
      parts.push({ type: 'text', value: input.slice(last, match.index) });
    }
    const rawToken = match[1]?.trim() ?? '';
    const overrideLabel = match[2]?.trim();
    const found = findTechFromToken(rawToken, eventTech);
    if (found) {
      usedKeys.add(found.key);
      parts.push({
        type: 'tech',
        tech: overrideLabel ? { ...found, label: overrideLabel } : found,
      });
    } else {
      const fallbackLabel = overrideLabel || rawToken;
      parts.push({
        type: 'tech',
        tech: {
          key: `inline:${normalizeToken(fallbackLabel)}`,
          label: fallbackLabel,
          tags: [],
        },
      });
    }
    last = re.lastIndex;
  }
  if (last < input.length) {
    parts.push({ type: 'text', value: input.slice(last) });
  }
  return { parts, usedKeys };
};

const preparedEvents = events.map((event) => {
  const titleInline = parseInlineTech(event.title, event.tech);
  const noteInline = parseInlineTech(event.note, event.tech);
  const usedKeys = new Set([...titleInline.usedKeys, ...noteInline.usedKeys]);
  const remainingTech = event.tech.filter((item) => !usedKeys.has(item.key));
  return {
    ...event,
    titleParts: titleInline.parts,
    noteParts: noteInline.parts,
    remainingTech,
  };
});
---

<section
  class="row"
  data-stack-row
  data-open="false"
  data-has-events={events.length > 0 ? 'true' : 'false'}
  aria-label={`${title} stack`}
>
  <header class="row-summary">
    <span class="row-left">
      <span class="row-title">{title}</span>
      <span class="row-range">{rangeLabel}</span>
    </span>

    <div class="row-inline-tech">
      <StackTechFold tech={tech} showToggle={false} />
    </div>

    <button
      type="button"
      class="row-toggle"
      data-row-toggle
      aria-expanded="false"
      aria-controls={panelId}
      aria-label={`Toggle ${title} details`}
    >
      <span class="row-chev" aria-hidden="true">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none">
          <path
            d="M6 9l6 6 6-6"
            stroke="currentColor"
            stroke-width="1.8"
            stroke-linecap="round"
            stroke-linejoin="round"></path>
        </svg>
      </span>
    </button>

    <div class="row-peek" aria-label="Stack summary">
      {summary && <p class="row-desc">{summary}</p>}
    </div>
  </header>

  <div
    class="row-body"
    id={panelId}
    data-row-panel
    hidden
    aria-hidden="true"
    style="display:none;"
  >
    {
      events.length > 0 && (
        <div class="row-events" aria-label="Changes">
          <h4>Changes</h4>
          <ul>
            {preparedEvents.map((e) => (
              <li>
                <time datetime={e.dateIso}>{e.dateLabel}</time>
                <div class="event-copy">
                  <p class="event-title">
                    {e.titleParts.map((part) =>
                      part.type === 'text' ? (
                        part.value
                      ) : (
                        <TechBadge
                          label={part.tech.label}
                          href={part.tech.href}
                          techKey={part.tech.key}
                          primaryTag={part.tech.tags[0]}
                        />
                      )
                    )}
                  </p>
                  {e.note && (
                    <p class="event-note">
                      {e.noteParts.map((part) =>
                        part.type === 'text' ? (
                          part.value
                        ) : (
                          <TechBadge
                            label={part.tech.label}
                            href={part.tech.href}
                            techKey={part.tech.key}
                            primaryTag={part.tech.tags[0]}
                          />
                        )
                      )}
                    </p>
                  )}
                  {e.remainingTech.length > 0 && (
                    <div class="event-tech" aria-label="Event technologies">
                      {e.remainingTech.map((item) => (
                        <TechBadge
                          label={item.label}
                          href={item.href}
                          techKey={item.key}
                          primaryTag={item.tags[0]}
                        />
                      ))}
                    </div>
                  )}
                </div>
              </li>
            ))}
          </ul>
        </div>
      )
    }
  </div>

  <script is:inline>
    function initStackRows() {
      const rows = Array.from(document.querySelectorAll('[data-stack-row]'));
      for (const row of rows) {
        if (row.dataset.bound === 'true') continue;
        row.dataset.bound = 'true';

        const btn = row.querySelector('[data-row-toggle]');
        const panel = row.querySelector('[data-row-panel]');
        const fold = row.querySelector('[data-tech-fold]');
        const summary = row.querySelector('.row-summary');
        if (!btn || !panel) continue;
        const hasEvents = row.getAttribute('data-has-events') === 'true';
        const prefersReduced = window.matchMedia?.(
          '(prefers-reduced-motion: reduce)'
        )?.matches;

        const captureSummaryRects = () => {
          const targets = [
            summary?.querySelector('.row-left'),
            summary?.querySelector('.row-peek'),
          ].filter(Boolean);
          const m = new Map();
          for (const el of targets) {
            m.set(el, el.getBoundingClientRect());
          }
          return m;
        };

        const animateSummaryFlip = (beforeRects) => {
          if (prefersReduced) return;
          for (const [el, before] of beforeRects.entries()) {
            const after = el.getBoundingClientRect();
            const dx = before.left - after.left;
            const dy = before.top - after.top;
            if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) continue;
            el.animate(
              [
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: 'translate(0px, 0px)' },
              ],
              { duration: 380, easing: 'cubic-bezier(0.33, 0, 0.67, 1)' }
            );
          }
        };

        const setOpen = (nextOpen, animate = true) => {
          const shouldAnimate = animate && !prefersReduced;
          const beforeRects = shouldAnimate ? captureSummaryRects() : undefined;

          row.setAttribute('data-open', nextOpen ? 'true' : 'false');
          btn.setAttribute('aria-expanded', nextOpen ? 'true' : 'false');
          const showPanel = nextOpen && hasEvents;
          panel.hidden = !showPanel;
          panel.setAttribute('aria-hidden', showPanel ? 'false' : 'true');
          panel.style.display = showPanel ? 'grid' : 'none';

          // Drive the same tech fold from compact (collapsed) to grouped (expanded).
          if (fold && typeof fold.__setOpen === 'function') {
            fold.__setOpen(nextOpen, animate);
          } else if (fold) {
            fold.setAttribute('data-open', nextOpen ? 'true' : 'false');
          }

          if (beforeRects && shouldAnimate) {
            requestAnimationFrame(() =>
              requestAnimationFrame(() => animateSummaryFlip(beforeRects))
            );
          }
        };

        btn.addEventListener('click', () => {
          const isOpen = row.getAttribute('data-open') === 'true';
          setOpen(!isOpen, true);
        });

        if (summary) {
          summary.addEventListener('click', (e) => {
            const target = e.target;
            if (!target || typeof target.closest !== 'function') return;
            if (target.closest('button')) return;
            if (target.closest('a')) return;
            if (target.closest('[data-tech-fold]')) return;
            if (!target.closest('.row-left')) return;
            const isOpen = row.getAttribute('data-open') === 'true';
            setOpen(!isOpen, true);
          });
        }

        // Defensive initialization: force collapsed state on first paint.
        setOpen(false, false);
      }
    }

    initStackRows();
  </script>
</section>

<style>
  .row {
    border: 1px solid var(--line);
    border-radius: 14px;
    background: var(--panel);
    box-shadow: var(--shadow);
    overflow: hidden;
  }

  .row-summary {
    padding: 0.7rem 0.8rem 0.85rem;
    display: grid;
    gap: 0.6rem;
    grid-template-columns: minmax(180px, auto) minmax(0, 1fr) auto;
    align-items: start;
    position: relative;
  }

  .row-left {
    cursor: pointer;
  }

  .row-summary::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 1px;
    background: var(--line);
    transform: scaleX(0);
    transform-origin: center;
    opacity: 0;
    transition:
      transform 380ms cubic-bezier(0.33, 0, 0.67, 1),
      opacity 320ms cubic-bezier(0.33, 0, 0.67, 1);
  }

  .row-left {
    display: grid;
    min-width: 0;
    gap: 0.14rem;
    grid-column: 1 / 2;
    grid-row: 1;
  }

  .row-title {
    font-size: 1.05rem;
    font-weight: 650;
    line-height: 1.2;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .row-range {
    font-family: var(--font-mono);
    font-size: 0.82rem;
    line-height: 1.25;
    color: var(--ink-soft);
    font-weight: 400;
    display: block;
  }

  .row-inline-tech {
    min-width: 0;
    grid-column: 2 / 3;
    grid-row: 1;
  }

  .row-toggle {
    appearance: none;
    border: 0;
    background: transparent;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: inherit;
    padding: 0;
    width: 30px;
    height: 30px;
    grid-column: 3 / 4;
    grid-row: 1;
    justify-self: end;
  }

  .row-chev {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--ink-soft);
    transition: transform 320ms cubic-bezier(0.33, 0, 0.67, 1);
  }

  .row[data-open='true'] .row-summary {
    background: transparent;
    grid-template-columns: minmax(0, 1fr) auto;
  }

  .row[data-open='true'][data-has-events='true'] .row-summary::after {
    transform: scaleX(1);
    opacity: 1;
  }

  .row[data-open='true'] .row-left {
    grid-column: 1 / 2;
    grid-row: 1;
  }

  .row[data-open='true'] .row-toggle {
    grid-column: 2 / 3;
    grid-row: 1;
  }

  .row[data-open='true'] .row-peek {
    grid-column: 1 / -1;
    grid-row: 2;
  }

  .row[data-open='true'] .row-inline-tech {
    grid-column: 1 / -1;
    grid-row: 3;
  }

  :global(
    .stack-wrap[data-tech-placement='below']
      .row[data-open='false']
      .row-summary
  ) {
    grid-template-columns: minmax(0, 1fr) auto;
  }

  :global(
    .stack-wrap[data-tech-placement='below'] .row[data-open='false'] .row-left
  ) {
    grid-column: 1 / 2;
    grid-row: 1;
  }

  :global(
    .stack-wrap[data-tech-placement='below'] .row[data-open='false'] .row-toggle
  ) {
    grid-column: 2 / 3;
    grid-row: 1;
  }

  :global(
    .stack-wrap[data-tech-placement='below'] .row[data-open='false'] .row-peek
  ) {
    grid-column: 1 / -1;
    grid-row: 2;
  }

  :global(
    .stack-wrap[data-tech-placement='below']
      .row[data-open='false']
      .row-inline-tech
  ) {
    grid-column: 1 / -1;
    grid-row: 3;
  }

  .row[data-open='true'][data-has-events='false'] .row-summary {
    border-bottom: 0;
  }

  .row[data-open='true'] .row-chev {
    transform: rotate(180deg);
  }

  .row-peek {
    display: grid;
    grid-template-columns: 1fr;
    gap: 0.4rem;
    grid-column: 1 / -1;
  }

  .row-toggle:focus-visible {
    outline: 2px solid color-mix(in srgb, var(--accent) 55%, transparent);
    outline-offset: 3px;
    border-radius: 10px;
  }

  .row-body {
    padding: 0.75rem 0.8rem 0.9rem;
    display: grid;
    gap: 0.7rem;
  }

  /* Defensive: never show events/details while collapsed. */
  .row[data-open='false'] .row-body,
  .row-body[hidden] {
    display: none !important;
  }

  .row-desc {
    margin: 0;
    color: var(--ink-soft);
  }

  .row-events h4 {
    margin: 0 0 0.35rem;
    font-family: var(--font-mono);
    font-size: 0.8rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--ink-soft);
  }

  .row-events ul {
    margin: 0;
    padding: 0;
    list-style: none;
    display: grid;
    gap: 0.6rem;
  }

  .row-events li {
    display: grid;
    grid-template-columns: 90px minmax(0, 1fr);
    gap: 0.6rem;
    align-items: start;
    border-left: 2px solid color-mix(in srgb, var(--line) 76%, transparent);
    border-radius: 0;
    background: transparent;
    padding: 0.1rem 0 0.1rem 0.65rem;
  }

  .row-events time {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: color-mix(in srgb, var(--ink-soft) 88%, var(--ink));
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding-top: 0.12rem;
  }

  .event-copy {
    min-width: 0;
    display: grid;
    gap: 0.28rem;
  }

  .event-title {
    margin: 0;
    line-height: 1.35;
    display: flex;
    flex-wrap: wrap;
    gap: 0.28rem;
    align-items: center;
  }

  .event-note {
    margin: 0;
    color: var(--ink-soft);
    font-size: 0.88rem;
    line-height: 1.4;
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    align-items: center;
  }

  .event-tech {
    display: flex;
    flex-wrap: wrap;
    gap: 0.32rem;
    margin-top: 0.06rem;
  }

  .event-tech :global(.tech-badge) {
    --tag-height: 20px;
    --tag-pad-y: 1px;
    --tag-pad-right: 7px;
    --tag-pad-left: 12px;
    --dot-size: 3px;
    --dot-left: 5px;
    --dot-ring: 1px;
    --icon-size: 10px;
    font-size: 0.65rem;
  }

  .event-title :global(.tech-badge),
  .event-note :global(.tech-badge) {
    --tag-height: 20px;
    --tag-pad-y: 1px;
    --tag-pad-right: 7px;
    --tag-pad-left: 12px;
    --dot-size: 3px;
    --dot-left: 5px;
    --dot-ring: 1px;
    --icon-size: 10px;
    font-size: 0.65rem;
    vertical-align: middle;
  }

  .row[data-open='true'] .row-events {
    animation: row-events-fade-in 340ms cubic-bezier(0.33, 0, 0.67, 1);
    transform-origin: top left;
  }

  @keyframes row-events-fade-in {
    from {
      opacity: 0;
      transform: translateY(4px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .row[data-open='true'] .row-events {
      animation: none;
    }
  }

  @media (max-width: 720px) {
    .row-summary {
      grid-template-columns: minmax(0, 1fr) auto;
    }

    .row-left {
      grid-column: 1 / 2;
      grid-row: 1;
    }

    .row-toggle {
      grid-column: 2 / 3;
      grid-row: 1;
    }

    .row-inline-tech {
      grid-column: 1 / -1;
      grid-row: 2;
    }

    .row-peek {
      grid-row: 3;
    }

    .row-title {
      white-space: normal;
    }

    .row-events li {
      grid-template-columns: minmax(0, 1fr);
      gap: 0.24rem;
      padding-left: 0.5rem;
    }
  }
</style>
