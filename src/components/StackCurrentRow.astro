---
import TechBadge from './TechBadge.astro';
import StackTechFold from './StackTechFold.astro';

type Category =
  | 'Languages'
  | 'Frameworks'
  | 'UI'
  | 'Data'
  | 'Identity'
  | 'Integrations'
  | 'Platforms/Hosting'
  | 'Infrastructure'
  | 'Tooling'
  | 'AI Tools'
  | 'AI Models/APIs';

type Tech = { key: string; label: string; href?: string; tags: Category[] };
type StackImage = { src: string; alt: string; caption?: string };

interface Props {
  contextId: string;
  title: string;
  rangeLabel: string;
  summary?: string;
  tech: Tech[];
  images?: StackImage[];
  events: Array<{
    dateIso: string;
    dateLabel: string;
    title: string;
    note?: string;
    tech: Tech[];
  }>;
}

const {
  contextId,
  title,
  rangeLabel,
  summary,
  tech,
  images = [],
  events,
} = Astro.props;

const panelId = `stack-row-panel-${contextId.replace(/[^a-zA-Z0-9_-]/g, '-')}`;

type InlinePart =
  | { type: 'text'; value: string }
  | { type: 'tech'; tech: Tech };

const normalizeToken = (value: string) =>
  value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '');

const findTechFromToken = (
  token: string,
  eventTech: Tech[]
): Tech | undefined => {
  const normalized = normalizeToken(token);
  if (!normalized) return undefined;
  const candidates = [...eventTech, ...tech];
  return candidates.find((item) => {
    const keyId = item.key.includes(':') ? item.key.split(':')[1] : item.key;
    return (
      normalizeToken(keyId) === normalized ||
      normalizeToken(item.label) === normalized
    );
  });
};

const parseInlineTech = (
  input: string | undefined,
  eventTech: Tech[]
): { parts: InlinePart[]; usedKeys: Set<string> } => {
  if (!input) return { parts: [], usedKeys: new Set() };
  const parts: InlinePart[] = [];
  const usedKeys = new Set<string>();
  const re = /\{\{tech:([^}|]+)(?:\|([^}]+))?\}\}/g;
  let last = 0;
  let match: RegExpExecArray | null = null;
  while ((match = re.exec(input)) !== null) {
    if (match.index > last) {
      parts.push({ type: 'text', value: input.slice(last, match.index) });
    }
    const rawToken = match[1]?.trim() ?? '';
    const overrideLabel = match[2]?.trim();
    const found = findTechFromToken(rawToken, eventTech);
    if (found) {
      usedKeys.add(found.key);
      parts.push({
        type: 'tech',
        tech: overrideLabel ? { ...found, label: overrideLabel } : found,
      });
    } else {
      const fallbackLabel = overrideLabel || rawToken;
      parts.push({
        type: 'tech',
        tech: {
          key: `inline:${normalizeToken(fallbackLabel)}`,
          label: fallbackLabel,
          tags: [],
        },
      });
    }
    last = re.lastIndex;
  }
  if (last < input.length) {
    parts.push({ type: 'text', value: input.slice(last) });
  }
  return { parts, usedKeys };
};

const preparedEvents = events.map((event) => {
  const titleInline = parseInlineTech(event.title, event.tech);
  const noteInline = parseInlineTech(event.note, event.tech);
  const usedKeys = new Set([...titleInline.usedKeys, ...noteInline.usedKeys]);
  const remainingTech = event.tech.filter((item) => !usedKeys.has(item.key));
  return {
    ...event,
    titleParts: titleInline.parts,
    noteParts: noteInline.parts,
    remainingTech,
  };
});
---

<section
  class="row"
  data-stack-row
  data-open="false"
  data-has-events={events.length > 0 ? 'true' : 'false'}
  aria-label={`${title} stack`}
>
  <header class="row-summary">
    <span class="row-left">
      <span class="row-title">{title}</span>
      <span class="row-range">{rangeLabel}</span>
    </span>

    <div class="row-inline-tech">
      <StackTechFold tech={tech} showToggle={false} />
    </div>

    <button
      type="button"
      class="row-toggle"
      data-row-toggle
      aria-expanded="false"
      aria-controls={panelId}
      aria-label={`Toggle ${title} details`}
    >
      <span class="row-chev" aria-hidden="true">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none">
          <path
            d="M6 9l6 6 6-6"
            stroke="currentColor"
            stroke-width="1.8"
            stroke-linecap="round"
            stroke-linejoin="round"></path>
        </svg>
      </span>
    </button>

    <div class="row-peek" aria-label="Stack summary">
      {summary && <p class="row-desc">{summary}</p>}
      {
        images.length > 0 && (
          <div class="row-media" aria-label="Stack screenshots">
            {images.map((image, index) => (
              <figure class="row-media-item">
                <button
                  type="button"
                  class="row-media-thumb"
                  data-media-open
                  data-media-src={image.src}
                  data-media-alt={image.alt}
                  data-media-caption={image.caption ?? ''}
                  aria-label={`Open screenshot ${index + 1} in large view`}
                >
                  <img src={image.src} alt={image.alt} loading="lazy" />
                </button>
              </figure>
            ))}
          </div>
        )
      }
    </div>
  </header>

  <div
    class="row-body"
    id={panelId}
    data-row-panel
    hidden
    aria-hidden="true"
    style="display:none;"
  >
    {
      events.length > 0 && (
        <div class="row-events" aria-label="Changes">
          <h4>Changes</h4>
          <ul>
            {preparedEvents.map((e) => (
              <li>
                <time datetime={e.dateIso}>{e.dateLabel}</time>
                <div class="event-copy">
                  <p class="event-title">
                    {e.titleParts.map((part) =>
                      part.type === 'text' ? (
                        part.value
                      ) : (
                        <TechBadge
                          label={part.tech.label}
                          href={part.tech.href}
                          techKey={part.tech.key}
                          primaryTag={part.tech.tags[0]}
                        />
                      )
                    )}
                  </p>
                  {e.note && (
                    <p class="event-note">
                      {e.noteParts.map((part) =>
                        part.type === 'text' ? (
                          part.value
                        ) : (
                          <TechBadge
                            label={part.tech.label}
                            href={part.tech.href}
                            techKey={part.tech.key}
                            primaryTag={part.tech.tags[0]}
                          />
                        )
                      )}
                    </p>
                  )}
                  {e.remainingTech.length > 0 && (
                    <div class="event-tech" aria-label="Event technologies">
                      {e.remainingTech.map((item) => (
                        <TechBadge
                          label={item.label}
                          href={item.href}
                          techKey={item.key}
                          primaryTag={item.tags[0]}
                        />
                      ))}
                    </div>
                  )}
                </div>
              </li>
            ))}
          </ul>
        </div>
      )
    }
  </div>

  {
    images.length > 0 && (
      <dialog class="row-media-dialog" data-media-dialog>
        <div class="row-media-dialog-inner">
          <div class="row-media-dialog-head">
            <p
              class="row-media-dialog-caption"
              data-media-dialog-caption
              hidden
            />
            <button
              type="button"
              class="row-media-dialog-close"
              data-media-close
              aria-label="Close screenshot"
            >
              Close
            </button>
          </div>
          <img
            class="row-media-dialog-image"
            data-media-dialog-image
            src=""
            alt=""
          />
        </div>
      </dialog>
    )
  }

  <script is:inline>
    function initStackRows() {
      const rows = Array.from(document.querySelectorAll('[data-stack-row]'));
      for (const row of rows) {
        if (row.dataset.bound === 'true') continue;
        row.dataset.bound = 'true';

        const btn = row.querySelector('[data-row-toggle]');
        const panel = row.querySelector('[data-row-panel]');
        const fold = row.querySelector('[data-tech-fold]');
        const summary = row.querySelector('.row-summary');
        if (!btn || !panel) continue;
        const hasEvents = row.getAttribute('data-has-events') === 'true';
        const prefersReduced = window.matchMedia?.(
          '(prefers-reduced-motion: reduce)'
        )?.matches;
        let frameToken = 0;
        let panelAnimation;

        const cancelPanelAnimation = () => {
          if (!panelAnimation) return;
          panelAnimation.cancel();
          panelAnimation = null;
        };

        const finishPanelStyles = () => {
          panel.style.height = '';
          panel.style.opacity = '';
          panel.style.overflow = '';
        };

        const captureSummaryRects = () => {
          const targets = [
            summary?.querySelector('.row-left'),
            summary?.querySelector('.row-peek'),
          ].filter(Boolean);
          const m = new Map();
          for (const el of targets) {
            m.set(el, el.getBoundingClientRect());
          }
          return m;
        };

        const captureLaneRects = () => {
          const currentWrap = row.closest('.row-wrap');
          const lane = currentWrap?.parentElement;
          if (!lane) return undefined;
          const wraps = Array.from(lane.children).filter((el) =>
            el.classList.contains('row-wrap')
          );
          const m = new Map();
          for (const wrap of wraps) {
            m.set(wrap, wrap.getBoundingClientRect());
          }
          return m;
        };

        const animateSummaryFlip = (beforeRects) => {
          if (prefersReduced) return;
          for (const [el, before] of beforeRects.entries()) {
            el.getAnimations().forEach((animation) => animation.cancel());
            const after = el.getBoundingClientRect();
            const dx = before.left - after.left;
            const dy = before.top - after.top;
            if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) continue;
            el.animate(
              [
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: 'translate(0px, 0px)' },
              ],
              {
                duration: 420,
                easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)',
                fill: 'both',
              }
            );
          }
        };

        const animateLaneShift = (beforeRects) => {
          if (prefersReduced || !beforeRects) return;
          for (const [el, before] of beforeRects.entries()) {
            el.getAnimations().forEach((animation) => animation.cancel());
            const after = el.getBoundingClientRect();
            const dy = before.top - after.top;
            if (Math.abs(dy) < 0.5) continue;
            el.animate(
              [
                { transform: `translateY(${dy}px)` },
                { transform: 'translateY(0px)' },
              ],
              {
                duration: 420,
                easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)',
                fill: 'both',
              }
            );
          }
        };

        const animatePanel = (nextOpen, animate = true) => {
          const showPanel = nextOpen && hasEvents;
          cancelPanelAnimation();

          if (!showPanel) {
            if (!animate || prefersReduced) {
              panel.hidden = true;
              panel.setAttribute('aria-hidden', 'true');
              panel.style.display = 'none';
              finishPanelStyles();
              return;
            }

            const fromHeight =
              panel.getBoundingClientRect().height || panel.scrollHeight;
            if (fromHeight <= 0) {
              panel.hidden = true;
              panel.setAttribute('aria-hidden', 'true');
              panel.style.display = 'none';
              finishPanelStyles();
              return;
            }
            panel.hidden = false;
            panel.setAttribute('aria-hidden', 'false');
            panel.style.display = 'grid';
            panel.style.overflow = 'hidden';
            panel.style.height = `${fromHeight}px`;
            panel.style.opacity = '1';

            panelAnimation = panel.animate(
              [
                { height: `${fromHeight}px`, opacity: 1 },
                { height: '0px', opacity: 0 },
              ],
              {
                duration: 360,
                easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)',
                fill: 'forwards',
              }
            );
            panelAnimation.onfinish = () => {
              panel.hidden = true;
              panel.setAttribute('aria-hidden', 'true');
              panel.style.display = 'none';
              finishPanelStyles();
              panelAnimation = null;
            };
            panelAnimation.oncancel = () => {
              panelAnimation = null;
            };
            return;
          }

          panel.hidden = false;
          panel.setAttribute('aria-hidden', 'false');
          panel.style.display = 'grid';

          if (!animate || prefersReduced) {
            finishPanelStyles();
            return;
          }

          panel.style.overflow = 'hidden';
          const fromHeight = panel.getBoundingClientRect().height;
          panel.style.height = 'auto';
          const toHeight = panel.scrollHeight;
          panel.style.height = `${fromHeight || 0}px`;
          panel.style.opacity = fromHeight > 0 ? '1' : '0';

          panelAnimation = panel.animate(
            [
              {
                height: `${fromHeight || 0}px`,
                opacity: fromHeight > 0 ? 1 : 0,
              },
              { height: `${toHeight}px`, opacity: 1 },
            ],
            {
              duration: 380,
              easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)',
              fill: 'forwards',
            }
          );
          panelAnimation.onfinish = () => {
            finishPanelStyles();
            panelAnimation = null;
          };
          panelAnimation.oncancel = () => {
            panelAnimation = null;
          };
        };

        const setOpen = (nextOpen, animate = true) => {
          const token = ++frameToken;
          const shouldAnimate = animate && !prefersReduced;
          const beforeRects = shouldAnimate ? captureSummaryRects() : undefined;
          const laneBeforeRects = shouldAnimate
            ? captureLaneRects()
            : undefined;

          row.setAttribute('data-open', nextOpen ? 'true' : 'false');
          btn.setAttribute('aria-expanded', nextOpen ? 'true' : 'false');
          animatePanel(nextOpen, shouldAnimate);

          // Drive the same tech fold from compact (collapsed) to grouped (expanded).
          if (fold && typeof fold.__setOpen === 'function') {
            fold.__setOpen(nextOpen, animate);
          } else if (fold) {
            fold.setAttribute('data-open', nextOpen ? 'true' : 'false');
          }

          if (beforeRects && shouldAnimate) {
            requestAnimationFrame(() =>
              requestAnimationFrame(() => {
                if (token !== frameToken) return;
                animateSummaryFlip(beforeRects);
                animateLaneShift(laneBeforeRects);
              })
            );
          }
        };

        btn.addEventListener('click', () => {
          const isOpen = row.getAttribute('data-open') === 'true';
          setOpen(!isOpen, true);
        });

        const mediaDialog = row.querySelector('[data-media-dialog]');
        const mediaImage = row.querySelector('[data-media-dialog-image]');
        const mediaCaption = row.querySelector('[data-media-dialog-caption]');
        const mediaClose = row.querySelector('[data-media-close]');
        const mediaOpenButtons = Array.from(
          row.querySelectorAll('[data-media-open]')
        );

        if (
          mediaDialog &&
          mediaImage &&
          mediaCaption &&
          mediaOpenButtons.length
        ) {
          const openMedia = (src, alt, caption = '') => {
            mediaImage.setAttribute('src', src);
            mediaImage.setAttribute('alt', alt);
            if (caption) {
              mediaCaption.textContent = caption;
              mediaCaption.hidden = false;
            } else {
              mediaCaption.textContent = '';
              mediaCaption.hidden = true;
            }
            if (typeof mediaDialog.showModal === 'function') {
              mediaDialog.showModal();
            } else {
              mediaDialog.setAttribute('open', 'true');
            }
          };

          const closeMedia = () => {
            if (typeof mediaDialog.close === 'function') mediaDialog.close();
            else mediaDialog.removeAttribute('open');
          };

          for (const button of mediaOpenButtons) {
            button.addEventListener('click', () => {
              const src = button.getAttribute('data-media-src') || '';
              const alt = button.getAttribute('data-media-alt') || '';
              const caption = button.getAttribute('data-media-caption') || '';
              if (!src) return;
              openMedia(src, alt, caption);
            });
          }

          if (mediaClose) mediaClose.addEventListener('click', closeMedia);
          mediaDialog.addEventListener('click', (e) => {
            if (e.target === mediaDialog) closeMedia();
          });
          mediaDialog.addEventListener('cancel', () => {
            mediaImage.setAttribute('src', '');
          });
          mediaDialog.addEventListener('close', () => {
            mediaImage.setAttribute('src', '');
          });
        }

        if (summary) {
          summary.addEventListener('click', (e) => {
            const target = e.target;
            if (!target || typeof target.closest !== 'function') return;
            if (target.closest('button')) return;
            if (target.closest('a')) return;
            if (target.closest('[data-tech-fold]')) return;
            if (!target.closest('.row-left')) return;
            const isOpen = row.getAttribute('data-open') === 'true';
            setOpen(!isOpen, true);
          });
        }

        // Defensive initialization: force collapsed state on first paint.
        setOpen(false, false);
      }
    }

    initStackRows();
  </script>
</section>

<style>
  .row {
    border: 1px solid var(--line);
    border-radius: 14px;
    background: var(--panel);
    box-shadow: var(--shadow);
    overflow: hidden;
  }

  .row-summary {
    padding: 0.7rem 0.8rem 0.85rem;
    display: grid;
    gap: 0.6rem;
    grid-template-columns: minmax(180px, auto) minmax(0, 1fr) auto;
    align-items: start;
    position: relative;
  }

  .row-left {
    cursor: pointer;
  }

  .row-summary::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 1px;
    background: var(--line);
    transform: scaleX(0);
    transform-origin: center;
    opacity: 0;
    transition:
      transform 380ms cubic-bezier(0.33, 0, 0.67, 1),
      opacity 320ms cubic-bezier(0.33, 0, 0.67, 1);
  }

  .row-left {
    display: grid;
    min-width: 0;
    gap: 0.14rem;
    grid-column: 1 / 2;
    grid-row: 1;
  }

  .row-title {
    font-size: 1.05rem;
    font-weight: 650;
    line-height: 1.2;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .row-summary:has(.row-left:hover, .row-toggle:hover) .row-title,
  .row-left:focus-within .row-title {
    text-decoration: underline;
    text-underline-offset: 0.2em;
  }

  .row-range {
    font-family: var(--font-mono);
    font-size: 0.82rem;
    line-height: 1.25;
    color: var(--ink-soft);
    font-weight: 400;
    display: block;
  }

  .row-inline-tech {
    min-width: 0;
    grid-column: 2 / 3;
    grid-row: 1;
  }

  .row-toggle {
    appearance: none;
    border: 0;
    background: transparent;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: inherit;
    padding: 0;
    width: 30px;
    height: 30px;
    grid-column: 3 / 4;
    grid-row: 1;
    justify-self: end;
    border-radius: 8px;
  }

  .row-toggle:hover,
  .row-summary:has(.row-left:hover, .row-toggle:hover) .row-toggle {
    background: color-mix(in srgb, var(--line) 52%, transparent);
  }

  .row-summary:has(.row-left:hover, .row-toggle:hover) .row-chev,
  .row-toggle:hover .row-chev {
    color: var(--ink);
  }

  .row-chev {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--ink-soft);
    transition: transform 320ms cubic-bezier(0.33, 0, 0.67, 1);
  }

  .row[data-open='true'] .row-summary {
    background: transparent;
    grid-template-columns: minmax(0, 1fr) auto;
  }

  .row[data-open='true'][data-has-events='true'] .row-summary::after {
    transform: scaleX(1);
    opacity: 1;
  }

  .row[data-open='true'] .row-left {
    grid-column: 1 / 2;
    grid-row: 1;
  }

  .row[data-open='true'] .row-toggle {
    grid-column: 2 / 3;
    grid-row: 1;
  }

  .row[data-open='true'] .row-peek {
    grid-column: 1 / -1;
    grid-row: 2;
  }

  .row[data-open='true'] .row-inline-tech {
    grid-column: 1 / -1;
    grid-row: 3;
  }

  :global(
    .stack-wrap[data-tech-placement='below']
      .row[data-open='false']
      .row-summary
  ) {
    grid-template-columns: minmax(0, 1fr) auto;
  }

  :global(
    .stack-wrap[data-tech-placement='below'] .row[data-open='false'] .row-left
  ) {
    grid-column: 1 / 2;
    grid-row: 1;
  }

  :global(
    .stack-wrap[data-tech-placement='below'] .row[data-open='false'] .row-toggle
  ) {
    grid-column: 2 / 3;
    grid-row: 1;
  }

  :global(
    .stack-wrap[data-tech-placement='below'] .row[data-open='false'] .row-peek
  ) {
    grid-column: 1 / -1;
    grid-row: 2;
  }

  :global(
    .stack-wrap[data-tech-placement='below']
      .row[data-open='false']
      .row-inline-tech
  ) {
    grid-column: 1 / -1;
    grid-row: 3;
  }

  .row[data-open='true'][data-has-events='false'] .row-summary {
    border-bottom: 0;
  }

  .row[data-open='true'] .row-chev {
    transform: rotate(180deg);
  }

  .row-peek {
    display: grid;
    grid-template-columns: 1fr;
    gap: 0.4rem;
    grid-column: 1 / -1;
  }

  .row-toggle:focus-visible {
    outline: 2px solid color-mix(in srgb, var(--accent) 55%, transparent);
    outline-offset: 3px;
    border-radius: 10px;
  }

  .row-body {
    padding: 0.75rem 0.8rem 0.9rem;
    display: grid;
    gap: 0.7rem;
  }

  /* Hidden attribute is the source of truth for collapsed state. */
  .row-body[hidden] {
    display: none !important;
  }

  .row-media {
    display: flex;
    flex-wrap: wrap;
    gap: 0.8rem;
  }

  .row[data-open='false'] .row-media {
    display: none;
  }

  .row-media-item {
    margin: 0;
    display: grid;
    width: min(100%, calc(20% - 0.64rem));
  }

  .row-media-thumb {
    appearance: none;
    border: 1px solid color-mix(in srgb, var(--line) 82%, transparent);
    background: color-mix(in srgb, var(--panel) 84%, #eef3fb);
    border-radius: 10px;
    padding: 0.2rem;
    cursor: zoom-in;
    overflow: hidden;
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .row-media-thumb:focus-visible {
    outline: 2px solid color-mix(in srgb, var(--accent) 55%, transparent);
    outline-offset: 2px;
  }

  .row-media-item img {
    width: 100%;
    height: auto;
    display: block;
    object-fit: contain;
  }

  .row-media-dialog {
    border: 1px solid var(--line);
    border-radius: 12px;
    background: var(--panel);
    color: var(--ink);
    padding: 0;
    width: min(92vw, 1024px);
    max-height: 92vh;
  }

  .row-media-dialog::backdrop {
    background: rgba(2, 8, 23, 0.62);
  }

  .row-media-dialog-inner {
    display: grid;
    gap: 0.6rem;
    padding: 0.7rem;
  }

  .row-media-dialog-head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.6rem;
  }

  .row-media-dialog-caption {
    margin: 0;
    font-size: 0.9rem;
    color: var(--ink-soft);
  }

  .row-media-dialog-close {
    appearance: none;
    border: 1px solid var(--line);
    border-radius: 999px;
    background: transparent;
    color: var(--ink);
    font-size: 0.85rem;
    padding: 0.25rem 0.7rem;
    cursor: pointer;
  }

  .row-media-dialog-image {
    width: 100%;
    max-height: 78vh;
    object-fit: contain;
    display: block;
    border-radius: 8px;
    border: 1px solid color-mix(in srgb, var(--line) 82%, transparent);
    background: color-mix(in srgb, var(--panel) 90%, #ecf2fb);
  }

  .row-desc {
    margin: 0;
    color: var(--ink-soft);
  }

  .row-events h4 {
    margin: 0 0 0.35rem;
    font-family: var(--font-mono);
    font-size: 0.8rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--ink-soft);
  }

  .row-events ul {
    margin: 0;
    padding: 0;
    list-style: none;
    display: grid;
    gap: 0.6rem;
  }

  .row-events {
    padding-bottom: 0.45rem;
    opacity: 1;
    transform: translateY(0);
    transition:
      opacity 180ms ease,
      transform 220ms cubic-bezier(0.22, 0.61, 0.36, 1);
    will-change: opacity, transform;
  }

  .row[data-open='false'] .row-events {
    opacity: 0;
    transform: translateY(-4px);
    pointer-events: none;
  }

  .row-events li {
    display: grid;
    grid-template-columns: 90px minmax(0, 1fr);
    gap: 0.6rem;
    align-items: start;
    border-left: 2px solid color-mix(in srgb, var(--line) 76%, transparent);
    border-radius: 0;
    background: transparent;
    padding: 0.1rem 0 0.1rem 0.65rem;
  }

  .row-events time {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: color-mix(in srgb, var(--ink-soft) 88%, var(--ink));
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding-top: 0.12rem;
  }

  .event-copy {
    min-width: 0;
    display: grid;
    gap: 0.28rem;
  }

  .event-title {
    margin: 0;
    line-height: 1.35;
    display: flex;
    flex-wrap: wrap;
    gap: 0.28rem;
    align-items: center;
  }

  .event-note {
    margin: 0;
    color: var(--ink-soft);
    font-size: 0.88rem;
    line-height: 1.4;
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    align-items: center;
  }

  .event-tech {
    display: flex;
    flex-wrap: wrap;
    gap: 0.32rem;
    margin-top: 0.06rem;
  }

  .event-tech :global(.tech-badge) {
    --tag-height: 20px;
    --tag-pad-y: 1px;
    --tag-pad-right: 7px;
    --tag-pad-left: 12px;
    --dot-size: 3px;
    --dot-left: 5px;
    --dot-ring: 1px;
    --icon-size: 10px;
    font-size: 0.65rem;
  }

  .event-title :global(.tech-badge),
  .event-note :global(.tech-badge) {
    --tag-height: 20px;
    --tag-pad-y: 1px;
    --tag-pad-right: 7px;
    --tag-pad-left: 12px;
    --dot-size: 3px;
    --dot-left: 5px;
    --dot-ring: 1px;
    --icon-size: 10px;
    font-size: 0.65rem;
    vertical-align: middle;
  }

  @media (max-width: 720px) {
    .row-summary {
      grid-template-columns: minmax(0, 1fr) auto;
    }

    .row-left {
      grid-column: 1 / 2;
      grid-row: 1;
    }

    .row-toggle {
      grid-column: 2 / 3;
      grid-row: 1;
    }

    .row-inline-tech {
      grid-column: 1 / -1;
      grid-row: 2;
    }

    .row-peek {
      grid-row: 3;
    }

    .row-title {
      white-space: normal;
    }

    .row-media-item {
      width: 100%;
    }

    .row-events li {
      grid-template-columns: minmax(0, 1fr);
      gap: 0.24rem;
      padding-left: 0.5rem;
    }
  }
</style>
