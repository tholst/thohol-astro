---
import StackTechList from './StackTechList.astro';

type Category =
  | 'Languages'
  | 'Frameworks'
  | 'UI'
  | 'Data'
  | 'Identity'
  | 'Integrations'
  | 'Platforms/Hosting'
  | 'Infrastructure'
  | 'Tooling'
  | 'AI Tools'
  | 'AI Models/APIs';

type Tech = { key: string; label: string; href?: string; tags: Category[] };

interface Props {
  tech: Tech[];
  showToggle?: boolean;
  foldRole?: 'preview' | 'detail';
}

const { tech, showToggle = true, foldRole = 'detail' } = Astro.props;
---

<section
  class="tech-fold"
  data-tech-fold
  data-fold-role={foldRole}
  data-open="false"
  aria-label="Tech list"
>
  <div class="tech-fold__content" aria-label="Tech badges">
    <StackTechList tech={tech} />
  </div>
  <span class="tech-fold__more" data-tech-more hidden>
    <span data-tech-more-count>0</span> more
  </span>

  {
    showToggle && (
      <button
        type="button"
        class="tech-fold__toggle"
        aria-expanded="false"
        aria-label="Toggle grouped tech view"
      >
        <span class="tech-fold__chev" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="none">
            <path
              d="M6 9l6 6 6-6"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </span>
      </button>
    )
  }

  <script is:inline>
    // One-time wiring for all tech folds on the page.
    function initTechFolds() {
      const prefersReduced = window.matchMedia?.(
        '(prefers-reduced-motion: reduce)'
      )?.matches;

      const folds = Array.from(document.querySelectorAll('[data-tech-fold]'));
      for (const fold of folds) {
        if (fold.dataset.bound === 'true') continue;
        fold.dataset.bound = 'true';

        const content = fold.querySelector('.tech-fold__content');
        const btn = fold.querySelector('.tech-fold__toggle');
        if (!content) continue;

        /** @type {Map<string, DOMRect>} */
        let before = new Map();

        const captureRects = () => {
          const m = new Map();
          const badges = content.querySelectorAll('[data-tech-key]');
          for (const el of badges) {
            const k = el.getAttribute('data-tech-key') || '';
            if (!k) continue;
            m.set(k, el.getBoundingClientRect());
          }
          return m;
        };

        const animateFlip = (after) => {
          if (prefersReduced) return;
          const badges = content.querySelectorAll('[data-tech-key]');
          for (const el of badges) {
            const k = el.getAttribute('data-tech-key') || '';
            if (!k) continue;
            const a = after.get(k);
            const b = before.get(k);
            if (!a || !b) continue;
            const dx = b.left - a.left;
            const dy = b.top - a.top;
            if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) continue;
            el.animate(
              [
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: 'translate(0px, 0px)' },
              ],
              { duration: 380, easing: 'cubic-bezier(0.33, 0, 0.67, 1)' }
            );
          }
        };

        const setOpen = (nextOpen) => {
          fold.setAttribute('data-open', nextOpen ? 'true' : 'false');
          if (btn)
            btn.setAttribute('aria-expanded', nextOpen ? 'true' : 'false');
        };

        const updateCompactOverflow = () => {
          const wrap = fold.closest('[data-tech-preview]');
          const previewMode = wrap?.getAttribute('data-tech-preview') || 'wrap';
          const isOpen = fold.getAttribute('data-open') === 'true';
          const more = fold.querySelector('[data-tech-more]');
          const moreCount = fold.querySelector('[data-tech-more-count]');
          const groups = content.querySelector('.tech-list__groups');
          if (!groups || !more || !moreCount) return;

          const badges = Array.from(
            content.querySelectorAll('[data-tech-key]')
          );
          for (const badge of badges) {
            badge.removeAttribute('data-compact-hidden');
          }

          if (isOpen || previewMode !== 'truncate') {
            more.hidden = true;
            return;
          }

          const max = content.clientWidth;
          if (!max || badges.length === 0) {
            more.hidden = true;
            return;
          }

          const styles = window.getComputedStyle(groups);
          const gapRaw = styles.columnGap || styles.gap || '0';
          const gap = Number.parseFloat(gapRaw) || 0;

          const fitCountWithReserve = (reserve) => {
            let used = 0;
            let fit = 0;
            for (const badge of badges) {
              const w = badge.getBoundingClientRect().width;
              const needed = fit === 0 ? w : w + gap;
              if (used + needed <= max - reserve) {
                used += needed;
                fit += 1;
              } else {
                break;
              }
            }
            return fit;
          };

          let fit = fitCountWithReserve(0);
          let hidden = Math.max(0, badges.length - fit);
          if (hidden === 0) {
            more.hidden = true;
            return;
          }

          more.hidden = false;
          moreCount.textContent = `+${hidden}`;
          let reserve = more.getBoundingClientRect().width + gap;
          fit = fitCountWithReserve(reserve);
          hidden = Math.max(0, badges.length - fit);
          if (hidden <= 0) {
            more.hidden = true;
            return;
          }
          moreCount.textContent = `+${hidden}`;
          reserve = more.getBoundingClientRect().width + gap;
          fit = fitCountWithReserve(reserve);
          hidden = Math.max(0, badges.length - fit);
          moreCount.textContent = `+${hidden}`;

          for (let i = fit; i < badges.length; i += 1) {
            badges[i].setAttribute('data-compact-hidden', 'true');
          }
        };

        const setOpenAnimated = (nextOpen, animate = true) => {
          const isOpen = fold.getAttribute('data-open') === 'true';
          if (isOpen === nextOpen) return;

          if (animate) before = captureRects();
          setOpen(nextOpen);
          if (!animate) return;

          // Two rAFs to ensure layout has fully settled after toggling styles.
          requestAnimationFrame(() =>
            requestAnimationFrame(() => {
              const after = captureRects();
              animateFlip(after);
              updateCompactOverflow();
            })
          );
        };

        const toggle = () => {
          const nextOpen = fold.getAttribute('data-open') !== 'true';
          setOpenAnimated(nextOpen, true);
        };

        if (btn) btn.addEventListener('click', toggle);

        // Make the whole tag area clickable only when the fold has its own toggle.
        if (btn) {
          content.addEventListener('click', (e) => {
            const target = e.target;
            if (!target || typeof target.closest !== 'function') return;
            if (target.closest('a')) return;
            if (target.closest('button')) return;
            toggle();
          });
        }

        // Allow a parent component (like the stack row) to drive the fold state.
        // @ts-expect-error - runtime-only hook added for parent-controlled fold state.
        fold.__setOpen = (nextOpen, animate = true) => {
          if (prefersReduced) animate = false;
          setOpenAnimated(Boolean(nextOpen), Boolean(animate));
        };

        const onPreviewModeChange = () => updateCompactOverflow();
        window.addEventListener(
          'stack:tech-preview-changed',
          onPreviewModeChange
        );
        window.addEventListener('resize', onPreviewModeChange);

        updateCompactOverflow();
      }
    }

    initTechFolds();
  </script>
</section>

<style>
  .tech-fold {
    display: grid;
    grid-template-columns: minmax(0, 1fr) auto auto;
    gap: 0.6rem;
    align-items: center;
    min-width: 0;
  }

  .tech-fold__toggle {
    appearance: none;
    border: 0;
    background: transparent;
    cursor: pointer;
    width: 30px;
    height: 30px;
    border-radius: 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--ink-soft);
    transition:
      transform 140ms ease,
      color 140ms ease;
  }

  .tech-fold__toggle:hover {
    color: var(--ink);
  }

  .tech-fold__toggle:focus-visible {
    outline: 2px solid color-mix(in srgb, var(--accent) 55%, transparent);
    outline-offset: 3px;
  }

  .tech-fold[data-open='true'] .tech-fold__toggle {
    transform: rotate(180deg);
  }

  .tech-fold__content {
    min-width: 0;
  }

  .tech-fold__more {
    font-family: var(--font-mono);
    font-size: 0.73rem;
    color: var(--ink-soft);
    white-space: nowrap;
  }

  /* Compact mode: flatten group boxes into a single row of badges. */
  .tech-fold[data-open='false'] :global(.tech-list__groups) {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    overflow: visible;
    padding-bottom: 0;
    mask-image: none;
  }

  .tech-fold[data-open='false'] :global([data-compact-hidden='true']) {
    display: none !important;
  }

  :global(
      .stack-wrap[data-tech-preview='truncate'] .tech-fold[data-open='false']
    )
    :global(.tech-list__groups) {
    flex-wrap: nowrap;
    overflow: hidden;
    position: relative;
    mask-image: linear-gradient(
      to right,
      #000 0,
      #000 calc(100% - 1.75rem),
      transparent 100%
    );
    -webkit-mask-image: linear-gradient(
      to right,
      #000 0,
      #000 calc(100% - 1.75rem),
      transparent 100%
    );
  }

  .tech-fold[data-open='false'] :global(.group) {
    display: contents;
  }

  .tech-fold[data-open='false'] :global(.group-title) {
    display: none;
  }

  .tech-fold[data-open='false'] :global(.group-items) {
    display: contents;
  }

  /* Grouped mode: show the structured groups from StackTechList. */
  .tech-fold[data-open='true'] :global(.tech-list__groups) {
    display: grid;
    gap: 0.65rem;
  }

  :global(.stack-wrap[data-tech-preview='wrap'] .tech-fold__more) {
    display: none;
  }

  .tech-fold[data-open='true'] .tech-fold__more {
    display: none;
  }

  @media (max-width: 720px) {
    .tech-fold {
      grid-template-columns: minmax(0, 1fr) auto;
      gap: 0.35rem;
    }

    .tech-fold__more {
      justify-self: end;
    }

    .tech-fold__toggle {
      justify-self: end;
    }
  }
</style>
