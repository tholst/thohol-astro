---
import BaseLayout from '../../layouts/BaseLayout.astro';
import StackCurrentRow from '../../components/StackCurrentRow.astro';
import StackHistoryContext from '../../components/StackHistoryContext.astro';
import { getCollection } from 'astro:content';
import { SITE_TITLE } from '../../consts';
import { FEATURES } from '../../config/features';

if (!FEATURES.stack) {
  return Astro.redirect('/');
}

type Category =
  | 'Languages'
  | 'Frameworks'
  | 'UI'
  | 'Data'
  | 'Identity'
  | 'Integrations'
  | 'Platforms/Hosting'
  | 'Infrastructure'
  | 'Tooling'
  | 'AI Tools'
  | 'AI Models/APIs';

type TechRef = string | { label: string; href?: string; tags?: Category[] };
type ResolvedTech = {
  key: string;
  label: string;
  href?: string;
  tags: Category[];
};
type StackEvent = { date: Date; title: string; note?: string; tech: TechRef[] };

type StackPeriod = {
  from: Date;
  to?: Date;
  summary?: string;
  tech?: TechRef[];
  // Backward compatible: earlier periods may still use `stack`.
  stack?: Record<Category, TechRef[]>;
  events: StackEvent[];
};

type StackContext = {
  id: string;
  title: string;
  order: number;
  periods: StackPeriod[];
};

type PeriodEvent = {
  dateIso: string;
  dateLabel: string;
  title: string;
  note?: string;
  tech: ResolvedTech[];
};

type PeriodDiff = { added: ResolvedTech[]; removed: ResolvedTech[] };

type ResolvedPeriod = {
  from: Date;
  to?: Date;
  fromIso: string;
  toIso?: string;
  rangeLabel: string;
  summary?: string;
  tech: ResolvedTech[];
  events: PeriodEvent[];
  diff?: PeriodDiff;
};

const CATEGORY_ORDER: Category[] = [
  'Languages',
  'Frameworks',
  'UI',
  'Data',
  'Identity',
  'Integrations',
  'Platforms/Hosting',
  'Infrastructure',
  'Tooling',
  'AI Tools',
  'AI Models/APIs',
];

const allContexts = await getCollection('stacks');
const contexts: StackContext[] = allContexts
  .filter((c) => c.data.published !== false)
  .map((c) => ({
    id: c.id,
    title: c.data.title,
    order: c.data.order,
    periods: c.data.periods,
  }))
  .sort((a, b) => a.order - b.order || a.title.localeCompare(b.title));

const allTech = await getCollection('tech');
const techById = new Map(
  allTech.filter((t) => t.data.published !== false).map((t) => [t.id, t.data])
);

function formatMonthYear(date: Date) {
  return new Intl.DateTimeFormat('en-US', {
    month: 'short',
    year: 'numeric',
  }).format(date);
}

function formatRange(from: Date, to: Date | undefined) {
  const fromLabel = formatMonthYear(from);
  if (!to) return `${fromLabel} – present`;
  const toLabel = formatMonthYear(to);
  if (fromLabel === toLabel) return fromLabel;
  return `${fromLabel} – ${toLabel}`;
}

function resolveRefWithTags(ref: TechRef): ResolvedTech {
  if (typeof ref === 'string') {
    const found = techById.get(ref);
    if (found) {
      const tags = Array.isArray(found.tags)
        ? (found.tags as Category[])
        : found.category
          ? ([found.category] as Category[])
          : ([] as Category[]);
      return { key: `id:${ref}`, label: found.title, href: found.href, tags };
    }
    return { key: `id:${ref}`, label: ref, tags: [] };
  }
  return {
    key: `label:${ref.label}`,
    label: ref.label,
    href: ref.href,
    tags: ref.tags ?? [],
  };
}

function resolvePeriod(period: StackPeriod): ResolvedPeriod {
  const legacyFlatFromStack: TechRef[] = [];
  if (period.stack) {
    for (const cat of CATEGORY_ORDER) {
      const items = period.stack[cat] ?? [];
      for (const item of items) {
        if (typeof item === 'string') legacyFlatFromStack.push(item);
        else legacyFlatFromStack.push({ ...item, tags: item.tags ?? [cat] });
      }
    }
  }

  const raw =
    period.tech && period.tech.length > 0 ? period.tech : legacyFlatFromStack;
  const tech = raw.map(resolveRefWithTags);

  const events = [...(period.events ?? [])]
    .sort((a, b) => b.date.valueOf() - a.date.valueOf())
    .map((ev) => ({
      dateIso: ev.date.toISOString(),
      dateLabel: formatMonthYear(ev.date),
      title: ev.title,
      note: ev.note,
      tech: (ev.tech ?? []).map(resolveRefWithTags),
    }));

  return {
    from: period.from,
    to: period.to,
    fromIso: period.from.toISOString(),
    toIso: period.to?.toISOString(),
    rangeLabel: formatRange(period.from, period.to),
    summary: period.summary,
    tech,
    events,
  };
}

function computeDiff(prev: ResolvedPeriod | undefined, cur: ResolvedPeriod) {
  if (!prev) return undefined;
  const prevKeys = new Set(prev.tech.map((t) => t.key));
  const curKeys = new Set(cur.tech.map((t) => t.key));
  return {
    added: cur.tech.filter((t) => !prevKeys.has(t.key)),
    removed: prev.tech.filter((t) => !curKeys.has(t.key)),
  };
}

function computeViewForContext(ctx: StackContext) {
  const sorted = [...ctx.periods].sort(
    (a, b) => a.from.valueOf() - b.from.valueOf()
  );
  const resolved = sorted.map(resolvePeriod);
  const diffs = resolved.map((p, idx) =>
    computeDiff(idx > 0 ? resolved[idx - 1] : undefined, p)
  );
  const withDiff = resolved.map((p, idx) => ({ ...p, diff: diffs[idx] }));

  const currentIndex = (() => {
    for (let i = withDiff.length - 1; i >= 0; i -= 1) {
      if (!withDiff[i].to) return i;
    }
    return withDiff.length - 1;
  })();

  const current = withDiff[currentIndex];
  const past = withDiff
    .filter((_, idx) => idx !== currentIndex)
    .sort((a, b) => b.from.valueOf() - a.from.valueOf());

  return { current, past };
}

function accentFor(id: string) {
  // Deterministic accent per stack context. Kept subtle by default; variants can
  // decide how loud to render it.
  let h = 0;
  for (let i = 0; i < id.length; i += 1) {
    h = (h * 31 + id.charCodeAt(i)) >>> 0;
  }
  const hue = h % 360;
  // Avoid neon-by-default; keep in a printable, confident range.
  return `hsl(${hue} 68% 42%)`;
}
---

<BaseLayout
  title={`Tech Stacks · ${SITE_TITLE}`}
  description="An evolving view of the technologies I use across projects and time."
>
  <main>
    <section class="intro">
      <h1>Tech Stacks</h1>
      <p>
        A living snapshot of the technologies I use, with expandable details and
        timeline history by context.
      </p>
    </section>

    {
      contexts.length === 0 ? (
        <p class="empty">No stack contexts published yet.</p>
      ) : (
        <div
          class="stack-wrap"
          data-stack-variant="v2"
          data-tag-shape="ultra"
          data-rail-width="none"
          data-rail-color="black"
          data-tech-preview="wrap"
          data-layout="type"
          data-tech-placement="below"
        >
          <section class="current" aria-label="Current stacks">
            <div class="rows">
              {contexts.map((ctx) => {
                const view = computeViewForContext(ctx);
                return (
                  <div
                    class="row-wrap"
                    data-stack-key={ctx.id}
                    style={`--stack-accent: ${accentFor(ctx.id)};`}
                  >
                    <StackCurrentRow
                      contextId={ctx.id}
                      title={ctx.title}
                      rangeLabel={view.current.rangeLabel}
                      summary={view.current.summary}
                      tech={view.current.tech}
                      events={view.current.events}
                    />
                  </div>
                );
              })}
            </div>
          </section>

          <section class="previous" aria-label="Previous stacks">
            <header class="section-head">
              <h2>Previous</h2>
              <p>Foldable history per context. Diffs show how it changed.</p>
            </header>

            <div class="history-list">
              {contexts.map((ctx) => {
                const view = computeViewForContext(ctx);
                return (
                  <div
                    class="row-wrap"
                    data-stack-key={ctx.id}
                    style={`--stack-accent: ${accentFor(ctx.id)};`}
                  >
                    <StackHistoryContext
                      contextId={ctx.id}
                      title={ctx.title}
                      periods={view.past.map((p) => ({
                        fromIso: p.fromIso,
                        toIso: p.toIso,
                        rangeLabel: p.rangeLabel,
                        summary: p.summary,
                        tech: p.tech,
                        events: p.events,
                        diff: p.diff,
                      }))}
                    />
                  </div>
                );
              })}
            </div>
          </section>
        </div>
      )
    }
  </main>
</BaseLayout>

<style>
  .intro p {
    margin: 0;
    color: var(--ink-soft);
  }

  .stack-wrap {
    margin-top: 1rem;
    display: grid;
    gap: 1.2rem;
  }

  :global(.stack-wrap .tech-badge) {
    background: transparent;
    border-color: color-mix(in srgb, var(--ink) 18%, var(--line));
    font-family: var(--font-mono);
  }

  :global(.stack-wrap .tech-badge:hover) {
    border-color: color-mix(in srgb, var(--tag-accent) 62%, var(--line));
    background: color-mix(in srgb, var(--tag-accent) 14%, var(--panel));
  }

  :global(.stack-wrap[data-tag-shape='ultra'] .tech-badge) {
    --tag-height: 21px;
    --tag-radius: 999px;
    --tag-pad-y: 1px;
    --tag-pad-right: 7px;
    --tag-pad-left: 12px;
    --dot-size: 3px;
    --dot-left: 5px;
    --dot-ring: 1px;
    --icon-size: 10px;
    font-size: 0.66rem;
  }

  .section-head h2 {
    margin: 0 0 0.25rem;
  }

  .section-head p {
    margin: 0;
    color: var(--ink-soft);
  }

  .rows,
  .history-list {
    margin-top: 0.8rem;
    display: grid;
    gap: 0.55rem;
  }

  .empty {
    margin-top: 1rem;
    color: var(--ink-soft);
  }

  /* Clean stack layout (single display variant) */
  :global(.stack-wrap[data-stack-variant='v2'] .rows),
  :global(.stack-wrap[data-stack-variant='v2'] .history-list) {
    gap: 0.85rem;
    border-top: 0;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-wrap) {
    position: relative;
    padding-left: 0;
  }

  :global(.stack-wrap[data-layout='type'] .row-title),
  :global(.stack-wrap[data-layout='type'] .history-title) {
    color: var(--accent);
    letter-spacing: -0.01em;
  }

  :global(.stack-wrap[data-layout='type'] .row-range),
  :global(.stack-wrap[data-layout='type'] .history-id),
  :global(.stack-wrap[data-layout='type'] .history-right) {
    font-family: var(--font-mono);
    font-size: 0.76rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  :global(.stack-wrap[data-layout='type'] .row-summary),
  :global(.stack-wrap[data-layout='type'] .history-summary),
  :global(.stack-wrap[data-layout='type'] .history-summary) {
    gap: 0.75rem;
  }

  :global(
    .stack-wrap[data-layout='type'] .row[data-open='true'] .row-summary::after
  ) {
    background: color-mix(in srgb, var(--accent) 36%, var(--line));
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-wrap) {
    padding-top: 0;
    padding-bottom: 0;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row),
  :global(.stack-wrap[data-stack-variant='v2'] .history) {
    border: 0;
    border-radius: 0;
    box-shadow: none;
    background: transparent;
    overflow: visible;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-summary),
  :global(.stack-wrap[data-stack-variant='v2'] .history-summary) {
    padding-left: 0;
    padding-right: 0;
    border-bottom: 0;
  }

  :global(
    .stack-wrap[data-stack-variant='v2'] .row[data-open='true'] .row-summary
  ),
  :global(
    .stack-wrap[data-stack-variant='v2'] details.history[open] .history-summary
  ) {
    background: transparent;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-title),
  :global(.stack-wrap[data-stack-variant='v2'] .history-title) {
    font-weight: 600;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-right),
  :global(.stack-wrap[data-stack-variant='v2'] .history-right) {
    color: color-mix(in srgb, var(--ink) 55%, var(--ink-soft));
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-body),
  :global(.stack-wrap[data-stack-variant='v2'] .history-body) {
    padding-left: 0;
    padding-right: 0;
    padding-top: 0.7rem;
    padding-bottom: 1rem;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .group) {
    border: 0;
    padding: 0;
    background: transparent;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .group-title) {
    margin-bottom: 0.3rem;
    color: color-mix(in srgb, var(--ink) 55%, var(--ink-soft));
  }
</style>
