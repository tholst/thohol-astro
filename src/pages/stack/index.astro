---
import BaseLayout from '../../layouts/BaseLayout.astro';
import StackCurrentRow from '../../components/StackCurrentRow.astro';
import StackHistoryContext from '../../components/StackHistoryContext.astro';
import { getCollection } from 'astro:content';
import { SITE_TITLE } from '../../consts';

type Category =
  | 'Languages'
  | 'Databases'
  | 'Backend'
  | 'Frontend'
  | 'Infra'
  | 'Tooling'
  | 'AI/Assistants';

type TechRef = string | { label: string; href?: string; tags?: Category[] };
type ResolvedTech = {
  key: string;
  label: string;
  href?: string;
  tags: Category[];
};
type StackEvent = { date: Date; title: string; note?: string; tech: TechRef[] };

type StackPeriod = {
  from: Date;
  to?: Date;
  summary?: string;
  tech?: TechRef[];
  // Backward compatible: earlier periods may still use `stack`.
  stack?: Record<Category, TechRef[]>;
  events: StackEvent[];
};

type StackContext = {
  id: string;
  title: string;
  order: number;
  periods: StackPeriod[];
};

type PeriodEvent = {
  dateIso: string;
  dateLabel: string;
  title: string;
  note?: string;
  tech: ResolvedTech[];
};

type PeriodDiff = { added: ResolvedTech[]; removed: ResolvedTech[] };

type ResolvedPeriod = {
  from: Date;
  to?: Date;
  fromIso: string;
  toIso?: string;
  rangeLabel: string;
  summary?: string;
  tech: ResolvedTech[];
  events: PeriodEvent[];
  diff?: PeriodDiff;
};

const CATEGORY_ORDER: Category[] = [
  'Languages',
  'Databases',
  'Backend',
  'Frontend',
  'Infra',
  'Tooling',
  'AI/Assistants',
];

const allContexts = await getCollection('stacks');
const contexts: StackContext[] = allContexts
  .filter((c) => c.data.published !== false)
  .map((c) => ({
    id: c.id,
    title: c.data.title,
    order: c.data.order,
    periods: c.data.periods,
  }))
  .sort((a, b) => a.order - b.order || a.title.localeCompare(b.title));

const allTech = await getCollection('tech');
const techById = new Map(
  allTech.filter((t) => t.data.published !== false).map((t) => [t.id, t.data])
);

function formatMonthYear(date: Date) {
  return new Intl.DateTimeFormat('en-US', {
    month: 'short',
    year: 'numeric',
  }).format(date);
}

function formatRange(from: Date, to: Date | undefined) {
  const fromLabel = formatMonthYear(from);
  if (!to) return `${fromLabel} – present`;
  const toLabel = formatMonthYear(to);
  if (fromLabel === toLabel) return fromLabel;
  return `${fromLabel} – ${toLabel}`;
}

function resolveRefWithTags(ref: TechRef): ResolvedTech {
  if (typeof ref === 'string') {
    const found = techById.get(ref);
    if (found) {
      const tags = Array.isArray(found.tags)
        ? (found.tags as Category[])
        : found.category
          ? ([found.category] as Category[])
          : ([] as Category[]);
      return { key: `id:${ref}`, label: found.title, href: found.href, tags };
    }
    return { key: `id:${ref}`, label: ref, tags: [] };
  }
  return {
    key: `label:${ref.label}`,
    label: ref.label,
    href: ref.href,
    tags: ref.tags ?? [],
  };
}

function resolvePeriod(period: StackPeriod): ResolvedPeriod {
  const legacyFlatFromStack: TechRef[] = [];
  if (period.stack) {
    for (const cat of CATEGORY_ORDER) {
      const items = period.stack[cat] ?? [];
      for (const item of items) {
        if (typeof item === 'string') legacyFlatFromStack.push(item);
        else legacyFlatFromStack.push({ ...item, tags: item.tags ?? [cat] });
      }
    }
  }

  const raw =
    period.tech && period.tech.length > 0 ? period.tech : legacyFlatFromStack;
  const tech = raw.map(resolveRefWithTags);

  const events = (period.events ?? []).map((ev) => ({
    dateIso: ev.date.toISOString(),
    dateLabel: formatMonthYear(ev.date),
    title: ev.title,
    note: ev.note,
    tech: (ev.tech ?? []).map(resolveRefWithTags),
  }));

  return {
    from: period.from,
    to: period.to,
    fromIso: period.from.toISOString(),
    toIso: period.to?.toISOString(),
    rangeLabel: formatRange(period.from, period.to),
    summary: period.summary,
    tech,
    events,
  };
}

function computeDiff(prev: ResolvedPeriod | undefined, cur: ResolvedPeriod) {
  if (!prev) return undefined;
  const prevKeys = new Set(prev.tech.map((t) => t.key));
  const curKeys = new Set(cur.tech.map((t) => t.key));
  return {
    added: cur.tech.filter((t) => !prevKeys.has(t.key)),
    removed: prev.tech.filter((t) => !curKeys.has(t.key)),
  };
}

function computeViewForContext(ctx: StackContext) {
  const sorted = [...ctx.periods].sort(
    (a, b) => a.from.valueOf() - b.from.valueOf()
  );
  const resolved = sorted.map(resolvePeriod);
  const diffs = resolved.map((p, idx) =>
    computeDiff(idx > 0 ? resolved[idx - 1] : undefined, p)
  );
  const withDiff = resolved.map((p, idx) => ({ ...p, diff: diffs[idx] }));

  const currentIndex = (() => {
    for (let i = withDiff.length - 1; i >= 0; i -= 1) {
      if (!withDiff[i].to) return i;
    }
    return withDiff.length - 1;
  })();

  const current = withDiff[currentIndex];
  const past = withDiff
    .filter((_, idx) => idx !== currentIndex)
    .sort((a, b) => b.from.valueOf() - a.from.valueOf());

  return { current, past };
}

function makePreview(tech: ResolvedTech[], max = 3) {
  const labels = tech.map((t) => t.label);
  const head = labels.slice(0, max);
  const rest = Math.max(0, labels.length - head.length);
  return rest > 0 ? `${head.join(' · ')} +${rest}` : head.join(' · ');
}
---

<BaseLayout
  title={`Stack · ${SITE_TITLE}`}
  description="Current and previous tech stacks across contexts and projects."
>
  <main>
    <section class="intro">
      <h1>Stack</h1>
      <p>
        Current stacks in compact form, plus a foldable history for older
        periods.
      </p>
    </section>

    {
      contexts.length === 0 ? (
        <p class="empty">No stack contexts published yet.</p>
      ) : (
        <div class="stack-wrap" data-tech-view="flat">
          <section class="controls" aria-label="Stack display controls">
            <div class="seg" role="group" aria-label="Tech grouping">
              <button
                type="button"
                data-tech-view-btn="flat"
                data-active="true"
              >
                Compact
              </button>
              <button type="button" data-tech-view-btn="grouped">
                Grouped
              </button>
            </div>
          </section>

          <section class="current" aria-label="Current stacks">
            <header class="section-head">
              <h2>Current</h2>
              <p>One line each. Expand a row for details.</p>
            </header>

            <div class="rows">
              {contexts.map((ctx) => {
                const view = computeViewForContext(ctx);
                return (
                  <div class="row-wrap">
                    <StackCurrentRow
                      contextId={ctx.id}
                      title={ctx.title}
                      preview={makePreview(view.current.tech, 3)}
                      rangeLabel={view.current.rangeLabel}
                      summary={view.current.summary}
                      tech={view.current.tech}
                      events={view.current.events}
                    />
                  </div>
                );
              })}
            </div>
          </section>

          <section class="previous" aria-label="Previous stacks">
            <header class="section-head">
              <h2>Previous</h2>
              <p>Foldable history per context. Diffs show how it changed.</p>
            </header>

            <div class="history-list">
              {contexts.map((ctx) => {
                const view = computeViewForContext(ctx);
                return (
                  <div class="row-wrap">
                    <StackHistoryContext
                      contextId={ctx.id}
                      title={ctx.title}
                      periods={view.past.map((p) => ({
                        fromIso: p.fromIso,
                        toIso: p.toIso,
                        rangeLabel: p.rangeLabel,
                        summary: p.summary,
                        tech: p.tech,
                        events: p.events,
                        diff: p.diff,
                      }))}
                    />
                  </div>
                );
              })}
            </div>
          </section>

          <script is:inline src="/stack-controls.js" defer />
        </div>
      )
    }
  </main>
</BaseLayout>

<style>
  .intro p {
    margin: 0;
    color: var(--ink-soft);
  }

  .stack-wrap {
    margin-top: 1rem;
    display: grid;
    gap: 1.2rem;
  }

  .controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    flex-wrap: wrap;
    border: 1px solid var(--line);
    border-radius: 14px;
    background: color-mix(in srgb, var(--panel) 80%, #f4f7fc);
    padding: 0.65rem 0.75rem;
  }

  .seg {
    display: inline-flex;
    gap: 0.35rem;
    padding: 0.35rem;
    border: 1px solid var(--line);
    border-radius: 999px;
    background: var(--panel);
  }

  .seg button {
    appearance: none;
    border: 1px solid transparent;
    border-radius: 999px;
    background: transparent;
    padding: 0.35rem 0.7rem;
    font-family: var(--font-mono);
    font-size: 0.82rem;
    color: var(--ink-soft);
    cursor: pointer;
  }

  .seg button[data-active='true'] {
    color: var(--ink);
    border-color: var(--accent);
    background: color-mix(in srgb, var(--accent) 12%, var(--panel));
  }

  .toggle {
    display: inline-flex;
    gap: 0.55rem;
    align-items: center;
    font-family: var(--font-mono);
    font-size: 0.82rem;
    color: var(--ink-soft);
  }

  .section-head h2 {
    margin: 0 0 0.25rem;
  }

  .section-head p {
    margin: 0;
    color: var(--ink-soft);
  }

  .rows,
  .history-list {
    margin-top: 0.8rem;
    display: grid;
    gap: 0.55rem;
  }

  .empty {
    margin-top: 1rem;
    color: var(--ink-soft);
  }
</style>
