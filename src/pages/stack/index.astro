---
import BaseLayout from '../../layouts/BaseLayout.astro';
import StackCurrentRow from '../../components/StackCurrentRow.astro';
import { getCollection } from 'astro:content';
import { SITE_TITLE } from '../../consts';
import { FEATURES } from '../../config/features';

if (!FEATURES.stack) {
  return Astro.redirect('/');
}

type Category =
  | 'Languages'
  | 'Frameworks'
  | 'UI'
  | 'Data'
  | 'Identity'
  | 'Integrations'
  | 'Platforms/Hosting'
  | 'Infrastructure'
  | 'Tooling'
  | 'AI Tools'
  | 'AI Models/APIs';

type TechRef = string | { label: string; href?: string; tags?: Category[] };
type ResolvedTech = {
  key: string;
  label: string;
  href?: string;
  tags: Category[];
};
type StackEvent = { date: Date; title: string; note?: string; tech: TechRef[] };

type StackPeriod = {
  from: Date;
  to?: Date;
  summary?: string;
  tech?: TechRef[];
  // Backward compatible: earlier periods may still use `stack`.
  stack?: Record<Category, TechRef[]>;
  events: StackEvent[];
};

type StackContext = {
  id: string;
  title: string;
  order: number;
  status: 'current' | 'past';
  periods: StackPeriod[];
};

type PeriodEvent = {
  dateIso: string;
  dateLabel: string;
  title: string;
  note?: string;
  tech: ResolvedTech[];
};

type ResolvedPeriod = {
  from: Date;
  to?: Date;
  fromIso: string;
  toIso?: string;
  rangeLabel: string;
  summary?: string;
  tech: ResolvedTech[];
  events: PeriodEvent[];
};

const CATEGORY_ORDER: Category[] = [
  'Languages',
  'Frameworks',
  'UI',
  'Data',
  'Identity',
  'Integrations',
  'Platforms/Hosting',
  'Infrastructure',
  'Tooling',
  'AI Tools',
  'AI Models/APIs',
];

const allContexts = await getCollection('stacks');
const contexts: StackContext[] = allContexts
  .filter((c) => c.data.published !== false)
  .map((c) => ({
    id: c.id,
    title: c.data.title,
    order: c.data.order,
    status: c.data.status,
    periods: c.data.periods,
  }))
  .sort((a, b) => a.order - b.order || a.title.localeCompare(b.title));

const allTech = await getCollection('tech');
const techById = new Map(
  allTech.filter((t) => t.data.published !== false).map((t) => [t.id, t.data])
);

function formatMonthYear(date: Date) {
  return new Intl.DateTimeFormat('en-US', {
    month: 'short',
    year: 'numeric',
  }).format(date);
}

function formatRange(from: Date, to: Date | undefined) {
  const fromLabel = formatMonthYear(from);
  if (!to) return `${fromLabel} – present`;
  const toLabel = formatMonthYear(to);
  if (fromLabel === toLabel) return fromLabel;
  return `${fromLabel} – ${toLabel}`;
}

function resolveRefWithTags(ref: TechRef): ResolvedTech {
  if (typeof ref === 'string') {
    const found = techById.get(ref);
    if (found) {
      const tags = Array.isArray(found.tags)
        ? (found.tags as Category[])
        : found.category
          ? ([found.category] as Category[])
          : ([] as Category[]);
      return { key: `id:${ref}`, label: found.title, href: found.href, tags };
    }
    return { key: `id:${ref}`, label: ref, tags: [] };
  }
  return {
    key: `label:${ref.label}`,
    label: ref.label,
    href: ref.href,
    tags: ref.tags ?? [],
  };
}

function resolvePeriod(period: StackPeriod): ResolvedPeriod {
  const legacyFlatFromStack: TechRef[] = [];
  if (period.stack) {
    for (const cat of CATEGORY_ORDER) {
      const items = period.stack[cat] ?? [];
      for (const item of items) {
        if (typeof item === 'string') legacyFlatFromStack.push(item);
        else legacyFlatFromStack.push({ ...item, tags: item.tags ?? [cat] });
      }
    }
  }

  const raw =
    period.tech && period.tech.length > 0 ? period.tech : legacyFlatFromStack;
  const tech = raw.map(resolveRefWithTags);

  const events = [...(period.events ?? [])]
    .sort((a, b) => b.date.valueOf() - a.date.valueOf())
    .map((ev) => ({
      dateIso: ev.date.toISOString(),
      dateLabel: formatMonthYear(ev.date),
      title: ev.title,
      note: ev.note,
      tech: (ev.tech ?? []).map(resolveRefWithTags),
    }));

  return {
    from: period.from,
    to: period.to,
    fromIso: period.from.toISOString(),
    toIso: period.to?.toISOString(),
    rangeLabel: formatRange(period.from, period.to),
    summary: period.summary,
    tech,
    events,
  };
}

function pickDisplayPeriod(ctx: StackContext) {
  const sorted = [...ctx.periods].sort(
    (a, b) => a.from.valueOf() - b.from.valueOf()
  );
  const resolved = sorted.map(resolvePeriod);

  const currentIndex = (() => {
    for (let i = resolved.length - 1; i >= 0; i -= 1) {
      if (!resolved[i].to) return i;
    }
    return resolved.length - 1;
  })();

  return resolved[currentIndex];
}

function accentFor(id: string) {
  // Deterministic accent per stack context. Kept subtle by default; variants can
  // decide how loud to render it.
  let h = 0;
  for (let i = 0; i < id.length; i += 1) {
    h = (h * 31 + id.charCodeAt(i)) >>> 0;
  }
  const hue = h % 360;
  // Avoid neon-by-default; keep in a printable, confident range.
  return `hsl(${hue} 68% 42%)`;
}

const currentContexts = contexts.filter((ctx) => ctx.status === 'current');
const pastContexts = contexts.filter((ctx) => ctx.status === 'past');
---

<BaseLayout
  title={`Tech Stacks · ${SITE_TITLE}`}
  description="An evolving view of the technologies I use across projects and time."
>
  <main>
    <section class="intro">
      <h1>Tech Stacks</h1>
      <p>Technology stacks I am currently working with.</p>
    </section>

    {
      contexts.length === 0 ? (
        <p class="empty">No stack contexts published yet.</p>
      ) : (
        <div
          class="stack-wrap"
          data-stack-variant="v2"
          data-tag-shape="ultra"
          data-rail-width="none"
          data-rail-color="black"
          data-tech-preview="wrap"
          data-layout="type"
          data-tech-placement="below"
        >
          <section class="current" aria-label="Current stacks">
            <div class="rows">
              {currentContexts.map((ctx) => {
                const period = pickDisplayPeriod(ctx);
                return (
                  <div
                    class="row-wrap"
                    data-stack-key={ctx.id}
                    style={`--stack-accent: ${accentFor(ctx.id)};`}
                  >
                    <StackCurrentRow
                      contextId={ctx.id}
                      title={ctx.title}
                      rangeLabel={period.rangeLabel}
                      summary={period.summary}
                      tech={period.tech}
                      events={period.events}
                    />
                  </div>
                );
              })}
            </div>
          </section>

          {pastContexts.length > 0 && (
            <details class="previous" aria-label="Past stacks">
              <summary class="previous-summary">
                <span class="previous-left">
                  <span class="previous-title">Stack Archive</span>
                  <span class="previous-count">
                    {pastContexts.length} archived
                  </span>
                </span>
                <span class="previous-chevron" aria-hidden="true">
                  <svg viewBox="0 0 24 24" width="18" height="18" fill="none">
                    <path
                      d="M6 9l6 6 6-6"
                      stroke="currentColor"
                      stroke-width="1.8"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    />
                  </svg>
                </span>
              </summary>

              <div class="history-list">
                {pastContexts.map((ctx) => {
                  const period = pickDisplayPeriod(ctx);
                  return (
                    <div
                      class="row-wrap"
                      data-stack-key={ctx.id}
                      style={`--stack-accent: ${accentFor(ctx.id)};`}
                    >
                      <StackCurrentRow
                        contextId={ctx.id}
                        title={ctx.title}
                        rangeLabel={period.rangeLabel}
                        summary={period.summary}
                        tech={period.tech}
                        events={period.events}
                      />
                    </div>
                  );
                })}
              </div>
            </details>
          )}
        </div>
      )
    }
  </main>
</BaseLayout>

<style>
  .intro p {
    margin: 0;
    color: var(--ink-soft);
  }

  .stack-wrap {
    margin-top: 1rem;
    display: grid;
    gap: 1.2rem;
  }

  :global(.stack-wrap .tech-badge) {
    background: transparent;
    border-color: color-mix(in srgb, var(--ink) 18%, var(--line));
    font-family: var(--font-mono);
  }

  :global(.stack-wrap .tech-badge:hover) {
    border-color: color-mix(in srgb, var(--tag-accent) 62%, var(--line));
    background: color-mix(in srgb, var(--tag-accent) 14%, var(--panel));
  }

  :global(.stack-wrap[data-tag-shape='ultra'] .tech-badge) {
    --tag-height: 21px;
    --tag-radius: 999px;
    --tag-pad-y: 1px;
    --tag-pad-right: 7px;
    --tag-pad-left: 12px;
    --dot-size: 3px;
    --dot-left: 5px;
    --dot-ring: 1px;
    --icon-size: 10px;
    font-size: 0.66rem;
  }

  .section-head h2 {
    margin: 0 0 0.25rem;
  }

  .section-head p {
    margin: 0;
    color: var(--ink-soft);
  }

  .previous {
    border: 0;
    margin: 0;
    padding: 0;
    margin-top: 0.35rem;
    padding-top: 0.75rem;
    border-top: 1px solid color-mix(in srgb, var(--line) 82%, transparent);
  }

  .previous-summary {
    list-style: none;
    cursor: pointer;
    display: grid;
    grid-template-columns: minmax(0, 1fr) auto;
    gap: 0.75rem;
    align-items: center;
    padding: 0.2rem 0;
    border-radius: 8px;
  }

  .previous > summary::-webkit-details-marker {
    display: none;
  }

  .previous-left {
    display: inline-flex;
    align-items: baseline;
    gap: 0.55rem;
    min-width: 0;
    flex-wrap: wrap;
  }

  .previous-title {
    font-size: 1.1rem;
    font-weight: 650;
    color: var(--accent);
    letter-spacing: -0.01em;
  }

  .previous-count {
    font-family: var(--font-mono);
    font-size: 0.76rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--ink-soft);
  }

  .previous-chevron {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--ink-soft);
    transition: transform 240ms cubic-bezier(0.33, 0, 0.67, 1);
  }

  .previous[open] .previous-chevron {
    transform: rotate(180deg);
  }

  .previous-summary:hover .previous-title {
    text-decoration: underline;
    text-underline-offset: 0.2em;
  }

  .previous-summary:focus-visible {
    outline: 2px solid color-mix(in srgb, var(--accent) 45%, transparent);
    outline-offset: 3px;
  }

  .rows,
  .history-list {
    margin-top: 0.8rem;
    display: grid;
    gap: 0.55rem;
  }

  .empty {
    margin-top: 1rem;
    color: var(--ink-soft);
  }

  /* Clean stack layout (single display variant) */
  :global(.stack-wrap[data-stack-variant='v2'] .rows),
  :global(.stack-wrap[data-stack-variant='v2'] .history-list) {
    gap: 0.85rem;
    border-top: 0;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-wrap) {
    position: relative;
    padding-left: 0;
  }

  :global(.stack-wrap[data-layout='type'] .row-title),
  :global(.stack-wrap[data-layout='type'] .history-title) {
    color: var(--accent);
    letter-spacing: -0.01em;
  }

  :global(.stack-wrap[data-layout='type'] .row-range),
  :global(.stack-wrap[data-layout='type'] .history-id),
  :global(.stack-wrap[data-layout='type'] .history-right) {
    font-family: var(--font-mono);
    font-size: 0.76rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  :global(.stack-wrap[data-layout='type'] .row-summary),
  :global(.stack-wrap[data-layout='type'] .history-summary),
  :global(.stack-wrap[data-layout='type'] .history-summary) {
    gap: 0.75rem;
  }

  :global(
    .stack-wrap[data-layout='type'] .row[data-open='true'] .row-summary::after
  ) {
    background: color-mix(in srgb, var(--accent) 36%, var(--line));
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-wrap) {
    padding-top: 0;
    padding-bottom: 0;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row),
  :global(.stack-wrap[data-stack-variant='v2'] .history) {
    border: 0;
    border-radius: 0;
    box-shadow: none;
    background: transparent;
    overflow: visible;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-summary),
  :global(.stack-wrap[data-stack-variant='v2'] .history-summary) {
    padding-left: 0;
    padding-right: 0;
    border-bottom: 0;
  }

  :global(
    .stack-wrap[data-stack-variant='v2'] .row[data-open='true'] .row-summary
  ),
  :global(
    .stack-wrap[data-stack-variant='v2'] details.history[open] .history-summary
  ) {
    background: transparent;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-title),
  :global(.stack-wrap[data-stack-variant='v2'] .history-title) {
    font-weight: 600;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-right),
  :global(.stack-wrap[data-stack-variant='v2'] .history-right) {
    color: color-mix(in srgb, var(--ink) 55%, var(--ink-soft));
  }

  :global(.stack-wrap[data-stack-variant='v2'] .row-body),
  :global(.stack-wrap[data-stack-variant='v2'] .history-body) {
    padding-left: 0;
    padding-right: 0;
    padding-top: 0.7rem;
    padding-bottom: 1rem;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .group) {
    border: 0;
    padding: 0;
    background: transparent;
  }

  :global(.stack-wrap[data-stack-variant='v2'] .group-title) {
    margin-bottom: 0.3rem;
    color: color-mix(in srgb, var(--ink) 55%, var(--ink-soft));
  }
</style>
