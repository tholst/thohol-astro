---
import BaseLayout from '../../layouts/BaseLayout.astro';
import FormattedDate from '../../components/FormattedDate.astro';
import { getCollection, render } from 'astro:content';

export async function getStaticPaths() {
  const tools = await getCollection('tools');
  const filteredTools = import.meta.env.PROD
    ? tools.filter((tool) => tool.data.published !== false)
    : tools;

  return filteredTools.map((tool) => ({
    params: { slug: tool.id },
    props: { tool },
  }));
}

const { tool } = Astro.props;
const { Content } = await render(tool);
const isSubnetPlanner = tool.id === 'subnet-planner';
---

<BaseLayout
  title={`${tool.data.title} · Tools`}
  description={tool.data.description}
>
  <main>
    <section class="tool-header">
      <a class="back-link" href="/tools/">← Back to tools</a>
      <h1>{tool.data.title}</h1>
      <p>{tool.data.description}</p>
      <p class="updated-at">
        Last updated on <FormattedDate date={tool.data.updatedAt} />
      </p>
    </section>

    {
      !isSubnetPlanner && (
        <article class="prose tool-prose">
          <Content />
        </article>
      )
    }

    {
      isSubnetPlanner && (
        <section class="tool-card" aria-label="Subnet Planner">
          <h2>Planner</h2>
          <p>
            Updates live while you type. Slider controls subnet size from one
            large subnet to the maximum possible split.
          </p>

          <form id="subnet-form" class="planner-form">
            <label>
              Base CIDR
              <input name="baseCidr" value="10.42.0.0/16" required />
            </label>

            <label>
              Number of required subnets
              <input
                name="count"
                type="number"
                min="1"
                max="65535"
                value="8"
                required
              />
            </label>

            <label class="slider-field full-row">
              Subnet split (IPs per subnet)
              <input
                id="splitLevel"
                name="splitLevel"
                type="range"
                min="0"
                max="16"
                value="8"
                step="1"
              />
              <div class="slider-scale">
                <span>1 subnet</span>
                <span>Maximum subnets</span>
              </div>
              <small id="splitSummary">
                /24 · 256 IPs/subnet · max 256 subnets
              </small>
            </label>

            <label class="full-row">
              Subnet name prefix
              <input name="namePrefix" value="subnet" />
            </label>

            <label class="full-row">
              Names (optional, comma-separated)
              <input
                name="names"
                value="hub-shared,aks-nodes,aks-pods,agw-ingress,bastion,azure-firewall,private-endpoints,data-services"
                placeholder="app, data, ingress, batch"
              />
            </label>
          </form>

          <p id="planner-message" class="planner-message" aria-live="polite" />

          <div class="results-box">
            <div class="results-header">
              <h3>Generated subnets</h3>
              <button
                type="button"
                id="copy-subnets"
                class="copy-icon"
                aria-label="Copy name and CIDR list"
                title="Copy name + CIDR"
                disabled
              >
                ⧉
              </button>
            </div>

            <div class="table-wrap">
              <table id="subnet-table" hidden>
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>CIDR</th>
                    <th>Network</th>
                    <th>First usable</th>
                    <th>Last usable</th>
                    <th>Broadcast</th>
                    <th>Hosts</th>
                  </tr>
                </thead>
                <tbody />
              </table>
            </div>
          </div>
        </section>
      )
    }
  </main>
</BaseLayout>

<style>
  .tool-header p {
    margin: 0;
    color: var(--ink-soft);
  }

  .updated-at {
    margin-top: 0.45rem;
    font-family: var(--font-mono);
    font-size: 0.8rem;
  }

  .back-link {
    display: inline-block;
    margin-bottom: 0.6rem;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    color: var(--ink-soft);
    text-decoration: none;
  }

  .tool-prose {
    margin-top: 1rem;
    padding-top: 0.9rem;
  }

  .tool-card {
    margin-top: 1rem;
    padding-top: 0.2rem;
  }

  .planner-form {
    display: grid;
    gap: 0.75rem;
    margin-top: 0.7rem;
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .planner-form label {
    display: grid;
    gap: 0.35rem;
    font-size: 0.9rem;
    color: var(--ink-soft);
  }

  .planner-form .full-row {
    grid-column: 1 / -1;
  }

  .planner-form input {
    border: 1px solid var(--line);
    border-radius: 6px;
    padding: 0.42rem 0.55rem;
    font: inherit;
    color: var(--ink);
    background: #fff;
  }

  .planner-form input[type='range'] {
    padding: 0;
  }

  .slider-field small {
    color: var(--ink-soft);
    font-family: var(--font-mono);
    font-size: 0.78rem;
  }

  .slider-scale {
    display: flex;
    justify-content: space-between;
    color: var(--ink-soft);
    font-size: 0.75rem;
  }

  .planner-message {
    margin: 0.8rem 0 0;
    color: var(--ink-soft);
    min-height: 1.2em;
  }

  .results-box {
    margin-top: 0.5rem;
    border: 1px solid var(--line);
    border-radius: 10px;
    padding: 0.6rem 0.6rem 0.2rem;
    background: #fff;
  }

  .results-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.45rem;
  }

  .results-header h3 {
    margin: 0;
    font-size: 0.82rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: var(--ink-soft);
    font-family: var(--font-mono);
  }

  .copy-icon {
    inline-size: 1.8rem;
    block-size: 1.8rem;
    display: inline-grid;
    place-items: center;
    border: 1px solid var(--line);
    border-radius: 6px;
    background: #fff;
    color: var(--ink-soft);
    font-size: 1rem;
    line-height: 1;
    padding: 0;
    cursor: pointer;
  }

  .copy-icon:hover:not(:disabled) {
    border-color: var(--ink-soft);
    color: var(--ink);
  }

  .copy-icon:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .table-wrap {
    overflow-x: auto;
    margin-top: 0.5rem;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
  }

  th,
  td {
    border-bottom: 1px solid var(--line);
    padding: 0.45rem 0.3rem;
    text-align: left;
    white-space: nowrap;
  }

  td:first-child,
  th:first-child {
    position: sticky;
    left: 0;
    background: #fff;
  }

  @media (max-width: 780px) {
    .planner-form {
      grid-template-columns: 1fr;
    }
  }
</style>

<script is:inline>
  const MAX_RENDERED_ROWS = 512;
  const form = document.getElementById('subnet-form');
  const table = document.getElementById('subnet-table');
  const tbody = table?.querySelector('tbody');
  const message = document.getElementById('planner-message');
  const slider = document.getElementById('splitLevel');
  const splitSummary = document.getElementById('splitSummary');
  const copyButton = document.getElementById('copy-subnets');

  const ipToInt = (ip) => {
    const parts = ip.split('.').map((v) => Number(v));
    if (
      parts.length !== 4 ||
      parts.some((v) => !Number.isInteger(v) || v < 0 || v > 255)
    ) {
      return null;
    }
    return (
      ((parts[0] << 24) >>> 0) +
      ((parts[1] << 16) >>> 0) +
      ((parts[2] << 8) >>> 0) +
      (parts[3] >>> 0)
    );
  };

  const intToIp = (intVal) =>
    [
      (intVal >>> 24) & 255,
      (intVal >>> 16) & 255,
      (intVal >>> 8) & 255,
      intVal & 255,
    ].join('.');

  const parseCidr = (value) => {
    const [ip, prefixRaw] = value.trim().split('/');
    const prefix = Number(prefixRaw);
    if (!ip || !Number.isInteger(prefix) || prefix < 0 || prefix > 32)
      return null;
    const ipInt = ipToInt(ip);
    if (ipInt === null) return null;
    const mask = prefix === 0 ? 0 : (0xffffffff << (32 - prefix)) >>> 0;
    const network = ipInt & mask;
    return { prefix, network };
  };

  const clearTable = () => {
    if (tbody) tbody.innerHTML = '';
    if (table) table.hidden = true;
    if (copyButton) copyButton.disabled = true;
  };

  const setMessage = (text, isError = false) => {
    if (!message) return;
    message.textContent = text;
    message.style.color = isError ? '#b42318' : '';
  };

  const appendCell = (row, text) => {
    const td = document.createElement('td');
    td.textContent = text;
    row.appendChild(td);
  };

  const generate = () => {
    if (!form) return;
    clearTable();

    const data = new FormData(form);
    const baseCidr = String(data.get('baseCidr') || '');
    const countRaw = Number(data.get('count'));
    const splitLevel = Number(data.get('splitLevel'));
    const namePrefix = String(data.get('namePrefix') || 'subnet').trim();
    const names = String(data.get('names') || '');

    const parsed = parseCidr(baseCidr);
    if (!parsed) {
      setMessage('Invalid base CIDR. Example: 10.42.0.0/16', true);
      return;
    }

    const maxSplit = 32 - parsed.prefix;
    const maxPossibleSubnets = 2 ** maxSplit;
    const count = Math.max(1, Number.isInteger(countRaw) ? countRaw : 1);

    if (count > maxPossibleSubnets) {
      setMessage(
        `Requested ${count} subnet(s), but at most ${maxPossibleSubnets} fit in ${baseCidr}.`,
        true
      );
      return;
    }

    const minRequiredSplit = Math.ceil(Math.log2(count));
    if (slider) {
      slider.max = String(maxSplit);
      slider.min = String(minRequiredSplit);
      if (splitLevel > maxSplit) slider.value = String(maxSplit);
      if (splitLevel < minRequiredSplit)
        slider.value = String(minRequiredSplit);
    }

    const split = Math.min(
      Math.max(Number(slider?.value || splitLevel), minRequiredSplit),
      maxSplit
    );
    const subnetPrefix = parsed.prefix + split;
    const subnetSize = 2 ** (32 - subnetPrefix);
    const maxSubnets = 2 ** split;

    if (splitSummary) {
      splitSummary.textContent = `/${subnetPrefix} · ${subnetSize} IPs/subnet · max ${maxSubnets} subnets`;
    }

    const limitedCount = Math.min(count, maxSubnets);
    const renderedCount = Math.min(limitedCount, MAX_RENDERED_ROWS);
    const countInput = form.elements.namedItem('count');
    if (countInput && 'max' in countInput) {
      countInput.max = String(maxPossibleSubnets);
    }

    const namesList = names
      .split(',')
      .map((v) => v.trim())
      .filter(Boolean);

    if (!tbody || !table) return;

    for (let i = 0; i < renderedCount; i += 1) {
      const network = (parsed.network + i * subnetSize) >>> 0;
      const broadcast = (network + subnetSize - 1) >>> 0;
      const firstUsable = subnetSize > 2 ? (network + 1) >>> 0 : network;
      const lastUsable = subnetSize > 2 ? (broadcast - 1) >>> 0 : broadcast;
      const usableHosts = subnetSize > 2 ? subnetSize - 2 : 0;

      const tr = document.createElement('tr');
      appendCell(
        tr,
        namesList[i] ||
          `${(namePrefix || 'subnet').replace(/\s+/g, '-')}-${i + 1}`
      );
      appendCell(tr, `${intToIp(network)}/${subnetPrefix}`);
      appendCell(tr, intToIp(network));
      appendCell(tr, intToIp(firstUsable));
      appendCell(tr, intToIp(lastUsable));
      appendCell(tr, intToIp(broadcast));
      appendCell(tr, String(usableHosts));
      tbody.appendChild(tr);
    }

    table.hidden = false;
    if (copyButton) copyButton.disabled = renderedCount === 0;
    if (limitedCount > renderedCount) {
      setMessage(
        `Generated ${limitedCount} subnet(s); showing first ${renderedCount} for readability.`
      );
    } else {
      setMessage(`Generated ${limitedCount} subnet(s).`);
    }
  };

  form?.addEventListener('submit', (event) => event.preventDefault());
  form?.addEventListener('input', generate);

  copyButton?.addEventListener('click', async () => {
    if (!tbody) return;
    const rows = Array.from(tbody.querySelectorAll('tr'));
    if (rows.length === 0) {
      setMessage('Nothing to copy yet.', true);
      return;
    }

    const lines = rows
      .map((row) => {
        const cells = row.querySelectorAll('td');
        const name = cells[0]?.textContent?.trim();
        const cidr = cells[1]?.textContent?.trim();
        return name && cidr ? `${name}: ${cidr}` : null;
      })
      .filter(Boolean)
      .join('\n');

    if (!lines) {
      setMessage('Nothing to copy yet.', true);
      return;
    }

    try {
      await navigator.clipboard.writeText(lines);
      setMessage(`Copied ${rows.length} subnet line(s) to clipboard.`);
    } catch {
      setMessage('Copy failed. Clipboard access was blocked.', true);
    }
  });

  generate();
</script>
